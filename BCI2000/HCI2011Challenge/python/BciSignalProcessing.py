
import numpy

class BciSignalProcessing(BciGenericSignalProcessing):
	
	"""
	This is only an example of the way you might choose to process the noisy one-channel input signal.
	As long as the finished product works with the current release of BCI2000, you could rewrite this
	signal-processing module in either Python or C++, redefining its parameters and behaviour as desired.
	
	Note that the competition places its emphasis on interface design rather than signal processing.
	Most of the work will be done in BciApplication.py rather than here. Your signal-processing should
	be fairly simple.  In particular, we advise against spending any time reverse-engineering the
	exact statistical properties of the SignalSource algorithm that generates the
	noisy input signal: in the judging and in the final event of the competition, the input signal will
	be *qualitatively* similar to that generated by NoisyInput.py, in that mouse movement will create
	a positive signal with a variable delay, a lot of noise, some refractory effect and a comparable
	amplitude to the current implementation.  However, the algorithm and parameters used to generate
	the signal will not necessarily be identical to those in the current NoisyInput.py
		
	"""
	
	def Construct(self):
		self.define_param("PythonSig float Threshold=       50     50 0 % // Signal threshold, above which to detect a response")
		self.define_param("PythonSig float RefractoryMsec= 500    500 0 % // Minimum time to wait between detections")
	
	def Preflight(self, inputProps):
		self.out_signal_props['ElementLabels'] = ['1']   # reduce to one time-sample per packet, for simplicity

	def Initialize(self, inputDims, outputDims):
		self.threshold  = float(self.params['Threshold'])
		self.refractory = float(self.params['RefractoryMsec'])
		
	def StartRun(self):
		self.forget('detection')
		
	def Process(self, inSig):
		
		outSig = numpy.matrix( [[0.0]] )
		
		if self.since('detection')['msec'] > self.refractory:
			if (inSig > self.threshold).any():
				outSig[0,0] = 1.0
				self.remember('detection')
		
		return outSig
		
	